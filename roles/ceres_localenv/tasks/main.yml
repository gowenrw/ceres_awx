---
# tasks main.yml file

# PREREQUISITES

## OS Check ##
- name: OS Check
  ansible.builtin.fail:
    msg: The role currently only supports CentOS and RHEL distributions.
  when: ansible_distribution not in ['CentOS', 'Red Hat Enterprise Linux']

## Resize Disk Tasks ##
#
# Get disk free space info for resize block conditional check
- name: Determine free space on disk
  ansible.builtin.shell: "parted {{ ceres_localenv_resize_dev }} unit GB print free | grep 'Free Space' | tail -n1 | awk '{print $3}' | sed 's/GB//'"
  register: reg_resize_disk_free_gb
  changed_when: False
  when: 
  - ceres_localenv_resize_disk
  - ansible_distribution == 'CentOS'
#
# Block for disk resize with conditionals for only CentOS, free space, etc.
- name: Resize Disk Block
  block:
    #
    # Get partition info for debugging
    - name: "Read disk {{ ceres_localenv_resize_dev }} information"
      community.general.parted: device={{ ceres_localenv_resize_dev }} unit=MiB
      register: reg_resize_disk_info
    #
    # Nested block for extending partition to rescue failure with brute force task
    - name: Extend Partition Block
      block:
        #
        # This is the correct way to resize a partition but seems to fail for my vagrant vms
        - name: Extend existing partition to fill all available space (nice way)
          community.general.parted:
            device: "{{ ceres_localenv_resize_dev }}"
            number: "{{ ceres_localenv_resize_part }}"
            part_end: "100%"
            resize: true
            state: present
          register: reg_resize_part_nice
      rescue:
        #
        # This is an ugly brute force way to resize a partition
        - name: Extend partition to fill all available space
          ansible.builtin.shell: "echo -e 'resizepart\n{{ ceres_localenv_resize_part }}\nYes\n100%\nprint free\nquit' | parted {{ ceres_localenv_resize_dev }} ---pretend-input-tty"
          register: reg_resize_part_force
    #
    # Extend the ext4 filesystem
    - name: Extend ext4 filesystem to fill all available space
      ansible.builtin.command: "resize2fs {{ ceres_localenv_resize_dev }}{{ ceres_localenv_resize_part }}"
      register: reg_resize_extfs
  #
  # Resize disk block conditionals
  when: 
    - ceres_localenv_resize_disk
    - reg_resize_disk_free_gb is defined
    - reg_resize_disk_free_gb.stdout | int > 1
    - ansible_distribution == 'CentOS'
  # Resize disk block Debugging
  always:
    #
    # Dump the output of block tasks if needed for troubleshooting
    - name: "Debug block tasks output"
      ansible.builtin.debug:
        msg:
        - "{{ omit if reg_resize_disk_info is not defined else reg_resize_disk_info }}"
        - "{{ omit if reg_resize_part_nice is not defined else reg_resize_part_nice}}"
        - "{{ omit if reg_resize_part_force is not defined else reg_resize_part_force}}"
        - "{{ omit if reg_resize_extfs is not defined else reg_resize_extfs}}"
        verbosity: 1

## DISABLE SELINUX & FIREWALLD
#
# selinux
- name: Disable SELinux
  ansible.posix.selinux:
    state: disabled
#
# firewalld
- name: Stop and Disable FirewallD
  ansible.builtin.service:
    name: firewalld
    state: stopped
    enabled: False

## SUDO SECURE_PATH
#
# Add /usr/local/bin to sudo secure_path
- name: Add /usr/local/bin to sudo secure_path
  ansible.builtin.lineinfile:
    line: Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
    regexp: Defaults(\s)*secure_path(\s)*=
    state: present
    insertafter: EOF
    path: /etc/sudoers
    validate: visudo -cf %s

## EPEL
#
# check if epel repo has already been configured
- name: Check if EPEL repo is already configured.
  stat:
    path: "{{ ceres_localenv_epel_repofile_path }}"
  register: reg_epel_repofile_result
#
# crb on centos
- name: Enable codeready-builder repository on CentOS 
  ansible.builtin.command: "dnf config-manager --set-enabled crb"
  when: 
    - not reg_epel_repofile_result.stat.exists
    - ansible_distribution == 'CentOS'
#
# epel on centos
- name: Install epel-release and epel-next-release on CentOS
  ansible.builtin.dnf:
    name:
      - epel-release
      - epel-next-release
    state: present
  when: 
    - not reg_epel_repofile_result.stat.exists
    - ansible_distribution == 'CentOS'
#
# crb on rhel
- name: Enable codeready-builder repository on RHEL
  community.general.rhsm_repository:
    name: codeready-builder-for-rhel-{{ ansible_distribution_major_version }}-{{ ansible_facts.architecture }}-rpms
  when: 
    - not reg_epel_repofile_result.stat.exists
    - ansible_distribution == 'Red Hat Enterprise Linux'
#
# gpg for epel on rhel
- name: Import EPEL GPG key on RHEL
  ansible.builtin.rpm_key:
    key: "{{ ceres_localenv_epel_repo_gpg_key_url }}"
    state: present
  register: reg_epel_rhel_gpg_result
  until: reg_epel_rhel_gpg_result is succeeded
  retries: 3
  delay: 10
  when: 
    - not reg_epel_repofile_result.stat.exists
    - ansible_distribution == 'Red Hat Enterprise Linux'
#
# epel on rhel
- name: Install EPEL repo.
  ansible.builtin.yum:
    name: "{{ ceres_localenv_epel_repo_url }}"
    state: present
  register: reg_epel_rhel_rhel_result
  until: reg_epel_rhel_rhel_result is succeeded
  retries: 3
  delay: 10
  when: 
    - not reg_epel_repofile_result.stat.exists
    - ansible_distribution == 'Red Hat Enterprise Linux'

## YUM UPDATE
#
# update the yum cache and all installed packages after epel repo add
- name: Update yum cache and all installed packages
  ansible.builtin.yum:
    name: '*'
    state: latest
    update_cache: True
    update_only: True
  register: reg_yum_update_result
#
# Dump the output of previous task if needed for troubleshooting
- name: "Debug task output"
  ansible.builtin.debug:
    var: reg_yum_update_result
    verbosity: 1

## INSTALL BUILD PKGS
#
# Install build packages
- name: Install build packages
  ansible.builtin.yum:
    name: "{{ ceres_localenv_pkgs_build_list }}"
    state: present
  register: reg_pkgs_build_result
  when: ceres_localenv_pkgs_build_install
#
# Dump the output of previous task if needed for troubleshooting
- name: "Debug task output"
  ansible.builtin.debug:
    var: reg_pkgs_build_result
    verbosity: 1

## INSTALL QUALITY OF LIFE PKGS
#
# Install quality of life packages
- name: Install qol packages
  ansible.builtin.yum:
    name: "{{ ceres_localenv_pkgs_qol_list }}"
    state: present
  register: reg_pkgs_qol_result
  when: ceres_localenv_pkgs_qol_install
#
# Dump the output of previous task if needed for troubleshooting
- name: "Debug task output"
  ansible.builtin.debug:
    var: reg_pkgs_qol_result
    verbosity: 1

## Custom color prompt
#
# Install custom color prompt
- name: Install custom color prompt to /etc/profile.d
  ansible.builtin.template:
    src: "setPS1.sh.j2"
    dest: "/etc/profile.d/setPS1.sh"
    owner: root
    group: root
    mode: "0444"
  when: 
    - ansible_distribution == 'CentOS'
    - ceres_localenv_custom_color_prompt

## INSTALL PUTTY PKG FROM SOURCE
#
# Check if PuTTy is already installed
- name: Check if PuTTy is already installed.
  stat:
    path: "{{ ceres_localenv_pkgs_putty_bin }}"
  register: reg_pkgs_puttybin_result
  when:
    - ceres_localenv_pkgs_putty_install
    - ansible_distribution == 'CentOS'
#
# Putty Install Block
- name: PuTTy Install Block
  block:
    #
    # Download putty source tarball
    - name: Download PuTTy source tarball
      ansible.builtin.get_url:
        url: "{{ ceres_localenv_pkgs_putty_url }}"
        dest: "{{ ceres_localenv_pkgs_putty_file }}"
      register: reg_pkgs_puttyurl_result
    #
    # Extract putty source tarball
    - name: Extract PuTTy source tarball
      ansible.builtin.unarchive:
        src: "{{ ceres_localenv_pkgs_putty_file }}"
        dest: "/tmp/"
        remote_src: yes
      register: reg_pkgs_puttytar_result
    #
    # Build putty from source and install
    - name: Run cmake in PuTTy source directory
      ansible.builtin.shell:
        cmd: cmake .; cmake --build .
        chdir: "{{ ceres_localenv_pkgs_putty_dir }}"
      register: reg_pkgs_puttycmake_result
    - name: Run cmake install in PuTTy source directory
      ansible.builtin.shell:
        cmd: cmake --build . --target install
        chdir: "{{ ceres_localenv_pkgs_putty_dir }}"
      register: reg_pkgs_puttycminstall_result
  # Putty Install Block Conditional
  when:
    - ceres_localenv_pkgs_putty_install
    - ansible_distribution == 'CentOS'
    - not reg_pkgs_puttybin_result.stat.exists
  # Putty Install Block Debugging
  always:
    #
    # Dump the output of block tasks if needed for troubleshooting
    - name: "Debug block tasks output"
      ansible.builtin.debug:
        msg:
        - "{{ omit if reg_pkgs_puttyurl_result is not defined else reg_pkgs_puttyurl_result }}"
        - "{{ omit if reg_pkgs_puttytar_result is not defined else reg_pkgs_puttytar_result}}"
        - "{{ omit if reg_pkgs_puttycmake_result is not defined else reg_pkgs_puttycmake_result}}"
        - "{{ omit if reg_pkgs_puttycminstall_result is not defined else reg_pkgs_puttycminstall_result}}"
        verbosity: 1

## INSTALL ANSIBLE PKGS
#
# Install ansible and podman
- name: Install ansible and podman packages
  ansible.builtin.yum:
    name:
      - ansible
      - podman
    state: present
  register: reg_pkgs_ans_result
  when: 
    - ceres_localenv_pkgs_ansible_install
    - ansible_distribution == 'CentOS'
#
# Dump the output of previous task if needed for troubleshooting
- name: "Debug task output"
  ansible.builtin.debug:
    var: reg_pkgs_ans_result
    verbosity: 1
#
# Install ansible-navigator pip
- name: Install ansible-navigator pip package
  ansible.builtin.pip:
    name: ansible-navigator
  register: reg_pkgs_ansn_result
  when: 
    - ceres_localenv_pkgs_ansible_install
    - ansible_distribution == 'CentOS'
#
# Dump the output of previous task if needed for troubleshooting
- name: "Debug task output"
  ansible.builtin.debug:
    var: reg_pkgs_ansn_result
    verbosity: 1
